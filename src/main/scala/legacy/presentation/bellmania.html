<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>bellmaniac demo</title>
    <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
    <meta name="author" content="Kuat Yessenov">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/theme/night.css" id="theme">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">
<style>   
    .reveal p { text-align: left; }
    .reveal pre code { margin: 0 auto; font-size: 120%; font-family: consolas; white-space: pre-wrap;}
</style>
<!--[if lt IE 9]>
<script src="lib/js/html5shiv.js"></script>
<![endif]-->
</head>

<body>
<div class="reveal">
<div class="slides">
<section>
<h1><em>Bellmaniac</em> Compiler</h1>
<h3>Kuat Yessenov</h3>
</section>

<section id='overview'>
<section>
<h2>Domain: Cache-oblivious algorithms</h2>
<blockquote>
... is an algorithm designed to take advantage of a CPU cache without having the size of the cache as a parameter
</blockquote>
<p>Example: Strassen's algorithm for matrix multiplication. </p>
<p>Typically work by subdividing problem recursively until an instance fits into a cache.</p>
<p>Cache-oblivious model:</p>
<ol>
<li>RAM machine model augmented with a second-level cache of size $M >= B^2$ for words of size $B$
<li>Cache miss has a cost (cache complexity)
<li>Goal 1: maintain optimal running time while minimizing cache complexity
<li>Goal 2: optimal for any $M$ and $B$  
</ol>
</section>

<section>
<h2>Example: Parenthesis problem (Yao'1980)</h2>
<blockquote>
Compute the minimum cost of parenthesizing $n$ elements given binary product as a primitive
(e.g. concatenation of sets of strings)
</blockquote>
<h3>Input</h3>
$$ c[i, i+1] = x_j $$
$$ c[i, j] = \min_{i \lt k \lt j}\left\{ c[i, k] + c[k, j] + w(i, k, j) \right\} $$
<h3>Output</h3>
<a href='paren.py'>autogenerated code</a>
<div class='fragment'>
<h3>Script</h3>
<a href='Paren.scala'>refinement script</a>
<a href='paren.svg'>proof overview</a>
</div>
</section>
<section>
<h3>Why deductive?</h3>
<ol>
<li>correct-by-construction
<li>automated performance analysis
<li>automated lowering
<li>opportunity for synthesis
</ol>
</section>
</section>

<section>
<h2>Compiler overview</h2>        
<h3>Problem definition</h3>
<p>
DSL for recurrence relations 
</p>

<h3>Refinement script</h3>
<p>
Tactics for stepwise refinement
</p>

<h3>Lowering</h3>
<p>
Compilation to low-level imperative code (we use Python+numpy)
</p>
</section>

<section>
<section>
<h3>Scala DSL: Parenthesis problem</h3>
<p>
$$ c[i, j] = \min_{i \lt k \leq j}\left\{ c[i, k] + c[k, j] + w(i, k, j) \right\} $$
</p>

<pre><code class="scala"  data-trim contenteditable>
val par = Algorithm(c, i :: j :: Nil,
// pre-condition
0 <= i and i < n and i < j and j < n,
// recursive definition
IF ((i === j-1) -> x(i)) 
ELSE
  Reduce(c(i, k) + c(k, j) + w(i, k, j) 
  where k in Range(i+1, j)))

// add to the environment
input(w); input(x); input(n)
add(par, j-i)
</code></pre>

<p>
Functions are state-less, provably terminating, and have only integer operations and monadic operators (reduce, zero, plus)
</p>
</section>
<section>
<h2>Proof environment</h2>
<p>A collection of mutually recursive functions together with:</p>
<ul>
  <li>a refinement relation: \(A \sqsubseteq B\) if A can be replaced by B in any context while preserving semantics.</li>
  <li>a restriction relation: pre-condition strengthening</li>
</ul>
<p>Initially: \(\{par\}\)</p>
<p>Goal: \(\{A_{par}, B_{par}, C_{par}, \ldots\}\)</p>         
<a href="paren.svg">Full derivation of parenthesis</a>
</section>

</section>

<section>
<section>
<h2>Refinement script</h2>

<p>A sequence of tactic applications over functions in the environment. Each tactic produces a new function that refines the input function (and may spawn new functions).</p>

<p>Tactic must <em>verify</em> correctness of the refinement. Environment is consistent at every step.</p>

<h3>Example</h3>
<pre><code class="scala"  data-trim contenteditable>
val R = Algorithm(r, List(i, j), par.pre, 
IF ((i === j-1) -> x(i)) ELSE Zero)
add(R, 0)

// first manually change expression of c to use r 
// $ just makes a fresh name for a variable
val par0 = manual($, 
// Op is the monadic operation used in Reduce
Op(Reduce(c(i, k) + c(k, j) + w(i, k, j) 
  where k in Range(i+1, j)), r(i, j)),
// tell prover ($$ is meant for prover) to unfold r above
$$.unfold($, R))(par)
</code></pre>
</section>
<section>
<h2>SMT prover technology</h2>

<p><em>Supports:</em> SAT, ILP, uninterpreted function symbols. Limited expressive power but reliable.</p>

<p class="fragment"><em>Missing:</em> inductive reasoning, folding/unfolding, modeling of higher-order functions, axiomatization of monadic operators, synthesis, ...</p>          

<p class="fragment" style="font-style: italic;">Think reasoning about symbolic expressions modulo SAT/integers</p>
</section>
<section>
<h2>Tactic repertoire</h2>
<h3>Basic</h3>
<p>
<ul>
  <li>manual: rewrite algorithm body and prove equivalence</li>
  <li>unfold: unfold a definition of an algorithm</li>
  <li>splitRange: divide list comprehension into two parts</li>
  <li>guard: add an "if" case for a special value</li>
  <li>relax: generalize pre-condition</li>        
  <li>introduce: add parameters</li>
</ul>
</p>
<h3>Contextual</h3>
<p>
<ul class="fragment">
  <li>selfRefine, refine: replace call to a function by its refinement</li>
  <li>specialize: replace call to a function by its restriction</li>
</ul>
</p>
<h3>Complex</h3>
<p>
<ul class="fragment">
  <li>genApp: generalize function use to a parameter</li>
  <li><b>split</b>: generate restrictions based on a partitioning scheme</li>
  <li><b>rewrite</b>: rewrite function arguments and prove by induction</li>
</ul>
</p>
</section>

<section>
<h3>Rewrite example</h3>
<p>Tactic:</p>
<pre><code class="scala" data-trim contenteditable>
val d110 = rewrite("d110", D, 
$$.splitRange($, k, n/4), $$.unfold($, D))(
i-&gt;(i-n/4), n-&gt;n/2, 
r-&gt;D.gen(2)(i, j, n/2, w&gt;&gt;(n/4,0,0), r&gt;&gt;(n/4,0), s&gt;&gt;(n/4,0), t),
w-&gt;(w&gt;&gt;(n/4,n/4,0)),
s-&gt;(s&gt;&gt;(n/4,n/4)),
t-&gt;(t&gt;&gt;(n/4,0))
)(d010)          
</code></pre>
<p>Input and output:</p>
<pre><code class="python" data-trim contenteditable>
def d010(i, j, n, w, r, s, t):
assert (((((0 <= i) and (i < n/2)) and (0 <= j)) and (j < n/2)) and ((not (i < n/4)) and (j < n/4)))
return d0(i, j, n, w, r, s, t)
def d110(i, j, n, w, r, s, t):
assert (((((0 <= i) and (i < n/2)) and (0 <= j)) and (j < n/2)) and ((not (i < n/4)) and (j < n/4)))
return d0((i - n/4), j, n/2, (lambda _v203, _v204, _v205: w((_v203 + n/4), (_v204 + n/4), _v205)), (lambda i201, j202: d0(i201, j202, n/2, (lambda _v194, _v195, _v196: w((_v194 + n/4), _v195, _v196)), (lambda _v197, _v198: r((_v197 + n/4), _v198)), (lambda _v199, _v200: s((_v199 + n/4), _v200)), t)), (lambda _v206, _v207: s((_v206 + n/4), (_v207 + n/4))), (lambda _v208, _v209: t((_v208 + n/4), _v209)))
</code></pre>
<p>Proof structure: unfold \(d_0\) once, apply induction hypothesis in the input, use hints* to prove symbolic equivalence.</p>
</section>

<section>
<h3>Analysis of tactic applications</h3>
<table class='reveal'>
<tr>
<th>Algorithm
<th>rewrite
<th>split
<th>splitRange*
<th>time (s)
<td># steps
<tr>
<td>Floyd
<td>17
<td>2
<td>0
<td>11s
<td>70
<tr>
<td>Gap
<td>12
<td>3
<td>12
<td>20s
<td>40
<tr>
<td>Parenthesis
<td>10
<td>3
<td>9
<td>2s
<td>40
</table>
</section>

<section>
<h2>Synthesis potential</h2>
<p>Improve prover to automate basic tactics (e.g. unfold, guard).</p>
<p class="fragment">Improve synthesizer to invoke contextual tactics given the current environment.</p>
<div class="fragment">
<p>Synthesize complex tactics</p>
<pre><code class="scala"  data-trim contenteditable>
val List(c1, c000, c001, c011) = 
split("c1", n < 4, i < n/2, j < n/2)(c0) 
val b100 = rewrite("b100", b0, 
$$.splitRange($, Var("k1"), n/4),
$$.unfold($, D))(
i-&gt;i,
j-&gt;(j-n/4),
n-&gt;n/2,        
w-&gt;(w&gt;&gt;(0,n/4,n/4)),
w1-&gt;(w1&gt;&gt;(0,0,n/4)),        
t-&gt;(t&gt;&gt;(n/4,n/4)),
// make d a function of i, j and pass the following arguments to d
r-&gt;D.gen(2)(i, j-n/4, n/2, w1&gt;&gt;(0,n/4,n/2), 
r&gt;&gt;(0,n/2),s&gt;&gt;(0,n/4),bij&gt;&gt;(n/4,n/2))          
)(b000)
</code></pre>
</div>
</section>
</section>

<section>
<section>
<h2>Lowering of proof environment to low-level code</h2>

<p><em>Input:</em> collection of mutually recursive math functions.</p>

<p><em>Output:</em> sequential code without \(\lambda\)s </p>
</section>

<section>
<h2>Lowering phases</h2>
<ul>
  <li>Full refinement, inlining: push all algorithms to the finest level</li>
  <li class="fragment">Add offsets as parameters:
  $$ \lambda i j . f(i + i_0, j + j_0) $$
  </li>
  <li class="fragment">Common subexpression elimination: reuse computation across split partitions</li>
  <li class="fragment">Memory read/write bound analysis: use SMT to compute loop bounds, etc</li>
</ul>
</section>

<section>
<h3>Projection of \(c_0\) to \(i, j\)</h3>
<pre style="font-size:80%;"><code class="scala"  data-trim contenteditable>
def c0(T, oi, oj, n, w, r, w_0, w_1, w_2, r_0, r_1):
for i0 in xrange(((-1)*n + 1),1):
  for j0 in xrange(((-1)*i0 + 1),n):
    i = (0 - i0)
    j = j0
    T[(i + oi), (j + oj)] = ...
</code></pre>
</section>

<section>
<h3>Projection of \(c_1\) to \(i, j\)</h3>
<pre style="font-size:80%;"><code class="scala"  data-trim contenteditable>
def c1(T, oi, oj, n, w, r, w_0, w_1, w_2, r_0, r_1):
if (n < 4):
  c0(T, oi, oj, n, w, r, w_0, w_1, w_2, r_0, r_1)
return
  c1(T, oi, oj, n/2, w, r, w_0, w_1, w_2, r_0, r_1)
  c1(T, (oi + n/2), (oj + n/2), n/2, w, r, (n/2 + w_0), (n/2 + w_1), (n/2 + w_2), (n/2 + r_0), (n/2 + r_1))
  b1(T, oi, oj, n, w, r, T, T, w, w_0, w_1, w_2, r_0, r_1, oi, oj, oi, oj, w_0, w_1, w_2)
</code></pre>
</section>

</section>

</div>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.min.js"></script>
<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({
  controls: true,
  progress: true,
  history: true,
  center: true,
  slideNumber: true,

  theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
  transition: Reveal.getQueryHash().transition || 'none', // default/cube/page/concave/zoom/linear/fade/none

  // Parallax scrolling
  // parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
  // parallaxBackgroundSize: '2100px 900px',

  // Optional libraries used to extend on reveal.js
  dependencies: [
  { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
  { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
  { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
  { src: 'plugin/math/math.js', async: true }
  ]
});

</script>
</body>
</html>
