\section{Tactics}
\label{tactics}

We now define the method with which our framework transforms program terms, by means of \newterm{tactics}.
A tactic is a scheme of equalities that can be used for rewriting.
When applied to a program term, any occurrence of the {\bf left-hand side} is replaced by the {\bf right-hand side}.%
\footnote{This is also a standard convention in Coq~\cite{COQ}, for example.}
A valid application of a tactic is an instance of the scheme that is well-typed and logically valid
(that is, the two sides have the same interpretation in any structure that interprets the free
variables occurring in the equality).

The application of tactics yields a sequence of program terms, each of which is checked to
be equivalent to the previous one. We refer to this sequence by the name \newterm{development}.

We associate with each tactic some \newterm{proof obligations}, listed after the word \textbf{\textit{Obligations}}
in the following paragraphs.
When applying a tactic instance, these obligations are also instantiated and given to an automated prover. 
If verified successfully, they entail the validity of the instance.
In some cases, the obligations are strictly stronger than the validity of the rewrite,
which means the TAE is not complete and may fail to apply a valid transformation.
It is important to note that the user does not have to specify, or in fact be aware of,
any proof obligations; they are defined as part of the tactic library.

The following are the major tactics provided by our framework. 
More tactic definitions are given in \Cref{annex:more tactics}.

\newcommand\Obligations{\medskip\noindent\textbf{\textit{Obligations}:} }
\newcommand\reduce{\operatorname{reduce}}
\newcommand\listConcat{{\scriptstyle \,++\,}}

\theoremstyle{definition}
\newtheorem{tactic}{Tactic}

\newcommand\tacticdef[1]{\subsection*{\sf\larger #1}}
\newcommand\tacticdefcompact[1]{\medskip\noindent{\sf\larger #1}\medskip\hfill}

\tacticdefcompact{Slice} \label{tactics:Slice}
$f ~=~ \big[f\big]_{X_1} ~\Big/~ \big[f\big]_{X_2} ~\Big/ ~\cdots~ \Big/~ \big[f\big]_{X_r}$\hspace{2mm}

This tactic partitions a mapping into sub-regions. Each $X_i$ may be a cross product ($\times$)
according to the arity of $f$.
For example, $X_1=J_0\times J_0$, $X_2=J_0\times J_1$, $X_3=J_1\times J_1$.

\Obligations just the above equality.

Informally, the recombination expression is equal to $f$
when $X_{1..r}$ ``cover'' all the defined points of $f$ (also known as the \newterm{support} of $f$).

\medskip
\tacticdefcompact{Stratify}
$\fix (f\applt g) ~=~ (\fix f) ~\applt~ \big(\psi\mapsto \fix (\widehat\psi\applt g)\big)$
\\
where $\widehat\psi$ abbreviates $\theta\mapsto\psi$, with fresh variable $\theta$.

This tactic is used to break a long (recursive) computation into steps. $\psi$ is bound the result of the first computation ($f$), and then used as the input for the second step ($g$).
Typically, we apply \textsf{Stratify} to a computation that has previously been \textsf{Slice}d (although that does not have to be the case); to understand the efficacy of \textsf{Stratify}, we present a minimal example.

Suppose the program $\fix \theta{\,\mapsto\,}\big([t]_{I_0}\big/[t]_{I_1}\big)$, where $t=i\mapsto\theta_{i-1}+1$.
We would like to obtain a program that computes the lower half $I_0$ first, then the upper half $I_1$; that is, 
$\big(\fix\theta\mapsto[t]_{I_0}\big/[\psi]_{I_1}\big) \applt
  \big(\psi \mapsto \fix\theta\mapsto[\psi]_{I_0}\big/[t]_{I_1}\big)$.

\begin{center}
\begin{tikzpicture}[node distance=.5cm, >=latex,
  array/.style={rectangle,draw,
                minimum width=2cm, minimum height=5mm},
  div/.style={shorten <=.5pt,shorten >=.5pt},
  block/.style={rectangle,fill=Orange, fill opacity=0.1, inner sep=0pt},
  src/.style={rounded corners=3pt,draw,dotted,fill=Orange, fill opacity=0.1, inner sep=1.5pt}]
  \node(s0)[array] {};
  \draw[div] (s0.north) -- (s0.south);
  
  \node(applt)[right=of s0] {$\applt$};
  
  \node(s1)[array,right=of applt] {};
  \draw[div] (s1.north) -- (s1.south);
  
  % labels
  \node(s0lbl)[below=0mm of s0] {$\fix\theta\mapsto[t]_{I_0}\big/[\psi]_{I_1}$};
  \node(s1lbl)[below=0mm of s1,anchor=140] {$\psi \mapsto \fix\theta\mapsto[\psi]_{I_0}\big/[t]_{I_1}$};
  
  % decoration
  \node(s0blk)[block,src,fit={(s0.north west) (s0.south)}] {};
  \node(s1blk)[block,fit={(s1.north) (s1.south east)}] {};
  
  \draw (s0blk.20) edge[->,out=10,in=160] (s1blk.center);
\end{tikzpicture}
\end{center}

This can be obtained by choosing 
$f=\theta\mapsto[t]_{I_0}\big/[\psi]_{I_1}$
and
$g=f\,\theta \mapsto [f\,\theta]_{I_0}\big/[t]_{I_1}$.

Notice how $f\,\theta$ is used as a placeholder for the sub-computation $f$ in $g$.
On the one hand, $f\applt g = \theta\mapsto\big[[t]_{I_0}\big/[\psi]_{I_1}\big]_{I_0}\big/[t]_{I_1}$, which,
modulo some simplification, is equivalent to the original term $\theta\mapsto[t]_{I_0}\big/[t]_{I_1}$.
On the other hand, when instantiating \textsf{Stratify}, $f\,\theta$ becomes $\widehat\psi\,\theta$, 
which is equivalent to $\psi$, giving the term for the second phase.

$\psi$ may be fresh, or it may reuse a variable already occurring in $g$, rebinding those occurrences.
This precisely encodes our intuition of computing the first fixed point \textit{in situ},
then the second one based on the result of the first.

\Obligations Let $h=f\applt g$ and $g'=\psi\mapsto\widehat\psi\applt g$. Let $\theta,\zeta$ be
fresh variables; then,\vspace{-.3em}
\begin{equation}
\renewcommand\arraystretch{1.5}
\begin{array}{l@{\qquad}l}
f\,(g'\,\zeta\,\theta) ~=~ f\,\zeta &
g'\,(f\,\theta)\,\theta ~=~ h\,\theta
\end{array}
\label{tactics:Stratify obligations}
\end{equation}

%Proof is given in \Cref{tactics:soundness}.

\vspace{.1em}
\tacticdefcompact{Synth} \label{tactics:Synth}
$\fix\big(h_1 ~\big/~ \cdots ~\big/~ h_r\big) ~=~ 
  f_1 :: \T_1 ~\big/~ \cdots ~\big/~ f_r :: \T_r$

This tactic is used to generate recursive calls to sub-programs. For $i=1..r$, $f_i$
is one of the following: $\fix h_i$, $h_i\,\psi$, or $t\,\psi$, where $\psi$ is some
variable and $t$ is a term corresponding to a previously defined subroutine
($A$, $B$, $C$ in the example).
Bellmania chooses these values automatically (see \Cref{tactics:synthesis}),
but the user may override it.

\newcommand\Y{\mathcal{Y}}

\Obligations Let $h=h_1/\cdots/h_r$, and let $\T\to\T$ be the shape of $h$. 
  For each $f_i$, depending on the form of $f_i$:
\begin{itemize}
  \item If $f_i \cong \fix f$ (for some $f$) --- \\
    \rule{0pt}{12pt}
    $h :: (\T \to \Y) = h :: (\Y \to \Y) = f :: (\Y \to \T)$
    for some $\Y$ which is a subtype of $\T$ and a supertype of $\T_i$.
  \item If $f_i$ does not contain any ``$\fix$'' terms ---\\
    \rule{0pt}{12pt}
    $h\,(h\,\theta) :: \T_i = f_i :: \T_i$ for a fresh variable $\theta$.
\end{itemize}

$\cong$ denotes syntactic congruence up to $\beta$-reduction.

\bigskip
\begin{theorem}
Let $s=s'$ be an instance of one of the tactics introduced in this section.
let $a_i=b_i$, $i=1..k$, be the proof obligations. If $\semp{a_i}=\semp{b_i}$
for all interpretations of the free variables of $a_i$ and $b_i$, then
$\semp{s}=\semp{s'}$ for all interpretations of the free variables of $s$ and $s'$.
\end{theorem}

Proof is given in \Cref{annex:proof}.


\newenvironment{tacticbox}[1]{\begin{center}
  \begin{tabular}{|@{~~~~}l@{~~~~}|}\hline
    \rule{0pt}{2.3ex}\underline{\sf \,#1\,}\\[.4em]$}
  {$\\[-1em] \\[.3ex] \hline \end{tabular} \end{center}}

\newenvironment{tacticboxInline}[1]{\begin{tabular}{|@{~~~}l@{~~~}|}\hline
    \rule{0pt}{2.3ex}\underline{\sf \,#1\,}\\[.4em]$}
  {$\\[-1em] \\[.3ex] \hline \end{tabular}}

\newcommand\vtyped[2]{\underset{\scriptscriptstyle ( #2 )}{ #1 }}
\newcommand\htyped[2]{({#1} : {\scriptstyle{#2}})}
\newcommand\htypednp[2]{{#1} : {\scriptstyle{#2}}}

% \quadrants{A}{B}{C}{D}   -- normal sized quadrants
% \quadrants*{A}{B}{C}{D}  -- small quadrants
\makeatletter
\newcommand{\quadrants@normal}[4]{
  \renewcommand\arraystretch{1.5}
   \begin{array}{c|c}
     #1 & #2 \\ \hline
     #3 & #4
   \end{array}}
\newcommand{\quadrants@small}[4]{
  \renewcommand\arraystretch{0.9}
   \begin{array}{@{~}c@{~}|@{~}c@{~}}
     \scriptstyle #1 & \scriptstyle #2 \\ \hline
     \scriptstyle #3 & \scriptstyle #4
   \end{array}}
\newcommand\quadrants{\@ifstar\quadrants@small\quadrants@normal}
\makeatother


\exampleTitle

\noindent
The na\"ive implementation of \Cref{intro:naive}
can be written as
%
\newcommand\Jsquaredltsml{J^2_{\mbox{\fontsize{6}{6}\selectfont \hspace{.5pt}<}}}
\begin{equation}
  \renewcommand\arraystretch{1.2}
  \begin{array}{@{}r@{}l@{}}
    \Psi ~=~ & i\,j\mapsto
	           [x_i]_{i+1=j} \\[2mm]
%
    A^{^{J}} ~=~ 
	      & \psi\mapsto \fix 
	        \htyped{\theta}{\Jsquaredltsml\to\R}~ \htyped{i}{J} ~ \htyped{j}{J}
	        ~\mapsto \\
	      &
          ~~
	      \begin{array}{@{}l@{}l@{}} 
	        \min\,\langle~ & \psi_{ij}, \\
	         & \min\, \htyped k J \mapsto\theta_{ik}+\theta_{kj}+w_{ikj}
	        ~\rangle
	      \end{array}
  \end{array}
  \label{tactics:paren phase A}
\end{equation}

%Vertical typeset was used to save some horizontal space, but $\vtyped v\T$
%should be read as just $v:\T$.

As mentioned in \Cref{overview}, the first step Richard does is to apply
{\sf Slice} to the program, thus introducing a partitioning into quadrants.

\smallskip

\begin{tacticbox}{Slice}
  \begin{array}{@{} l  l @{}}
       f ~=~ \theta\,i\,j\mapsto \cdots \\
       X_1 ~=~ \_\times J_0\times J_0 &
       X_2 ~=~ \_\times J_0\times J_1 \\
	   &
       X_3 ~=~ \_\times J_1\times J_1 \\[.5em]
       \cspan2{\mbox{\small ({\it each} ``\_'' {\it is a fresh type variable})}}
  \end{array}
\end{tacticbox}
\vspace{-2mm}
%
\begin{flalign}
  ~A^{^J} = \psi\mapsto \fix \quadrants{\qbox1}{\qbox2}{}{\qbox4} &&
  \label{tactics:A sliced}
\end{flalign}
\vspace{-2mm}
\[
  \renewcommand\arraystretch{1.2}
  ~~~
  \begin{array}{@{}r@{}l@{~}c@{~}c@{}l@{}l@{}}
	\qbox1 ~=~ & \theta\,& \htyped{i}{J_0} & \htyped{j}{J_0} & {}\mapsto  \\ 
	 & \lspan4{\qquad \min\,\langle~ \psi_{ij}, \min\, \htyped k J \mapsto\theta_{ik} + \theta_{kj} + w_{ikj} ~\rangle} \\
	\qbox2 ~=~ & \theta\,& \htyped{i}{J_0} & \htyped{j}{J_1} & {}\mapsto \\
	 & \lspan4{\qquad \min\,\langle~ \psi_{ij}, \min\, \htyped k J \mapsto\theta_{ik} + \theta_{kj} + w_{ikj} ~\rangle} \\
	\qbox4 ~=~ & \theta\,& \htyped{i}{J_1} & \htyped{j}{J_1} & {}\mapsto \\
	 & \lspan4{\qquad \min\,\langle~ \psi_{ij}, \min\, \htyped k J \mapsto\theta_{ik} + \theta_{kj} + w_{ikj} ~\rangle} \\
  \end{array}
\]

With repeated applications of {\sf Slice}, a program may grow to become
quite large; to make large program terms easy to read and refer to, we provide
boxed numerals \qbox1, \qbox2, etc. as labels for sub-terms, using them as abbreviations for these terms where they
occur in the containing expression.

In addition, to allude to the reader's intuition, expressions of the form
$a/b/c/d$ will be written as $\quadrants*{a}{b}{c}{d}$ when the slices
represent quadrants. The types of the quadrants should be clear from the context;
here, their types are 
\vspace{-.5em}
\[\htypednp{\qbox1}{\_{\times}J_0{\times}J_0\to\R},~ \htypednp{\qbox2}{\_{\times}J_0{\times}J_1\to\R},~ \htypednp{\qbox4}{\_{\times}J_1{\times}J_1\to\R}\]

The type of $\theta$ in \Cref{tactics:A sliced} is still
$\Jsquaredlt\to\R$. In order to avoid too much clutter caused by type terms,
the Bellmania UI uses a heuristic and only displays some of them. By hovering,
the user can inspect types that are not shown.

The result is a functional representation of \Cref{overview:logical-slice-stratify}$(a)$;
with the added term $\psi_{ij}$ it allows $A$ to accept an input array as an argument
and minimize values that are already stored in it; not quite crucial for this particular
instance where the input is just $\Psi$, but very useful in cases where it is necessary
to split a minimization operation into several sub-ranges, to achieve the desired
memory locality.

\newcommand\lifted[1]{\widehat{#1}}

\begin{tacticbox}{Stratify \qbox 1}
  \begin{array}{@{} l @{} l @{}}
    f ~=~ \quadrants*{\tinyqbox1}{\lifted\psi}{\lifted\psi}{\lifted\psi}
         & \mbox{\small ({\it recall that } $\widehat\psi=\theta\mapsto\psi$)} \\
    g ~=~ z\mapsto\quadrants*{z}{\tinyqbox{2}}{}{\tinyqbox4} &
    \qquad\quad\psi=\psi
  \end{array}
\end{tacticbox}

\begin{equation}
  \renewcommand\arraystretch{1.5}
  \begin{array}{@{}l@{}} %@{}l@{}c@{}c@{}l@{}l@{}}
    A^{^J} =~ \psi\mapsto \left(\!\fix\, \quadrants{\qbox1}{\lifted\psi}{\lifted\psi}{\lifted\psi}\right) \applt 
       ~~\psi \mapsto \fix\, \quadrants{\lifted\psi}{\qbox2}{}{\qbox4} \\
    \quad
    \qbox1 \,\qbox2 \,\qbox4 \textit{ as in \Cref{tactics:A sliced}}
  \end{array}
  \label{evaluation:A stratified}
\end{equation}

The reason for this particular choice of $f$ and $g$ is as explained in
\Cref{tactics}. Richard does not have to worry too much about them, because
they are encoded in the tactic application engine,
so that Bellmania knows how to build them automatically
based on the term being stratified (\qbox1 in this case).

Notice that an existing variable $\psi$ is reused, rebinding any occurrences within $\qbox2$\,, $\qbox4$\,.
This effect is desirable, as it limits the context of the expression: the inner $\psi$ shadows the outer $\psi$,
meaning $\qbox2$\,, $\qbox4$ do not need to access the data that was input to $\qbox1$\,, only its
output; therefore $\qbox1$ can be computed in-place.
The proof obligations for {\sf Stratify} make sure this transition is valid.

At this point Richard can either do another {\sf Stratify} or a {\sf Synth}.
The order is insignificant, but to be consistent with \Cref{overview:slice-stratify-synth},
let us assume he chooses the former.

\medskip

\begin{tacticbox}{Stratify \qbox1}
  \begin{array}{@{} l @{} l @{}}
    f ~=~ \quadrants*{\tinyqbox1}{\lifted\psi}{\lifted\psi}{\lifted\psi}
         & \mbox{\small ({\it recall that } $\widehat\psi=\theta\mapsto\psi$)} \\
    g ~=~ z\mapsto\quadrants*{z}{\tinyqbox2}{}{\tinyqbox4} &
    \qquad\quad\psi=\psi
  \end{array}
\end{tacticbox}

\begin{equation}
  \renewcommand\arraystretch{1.5}
  \begin{array}{@{} r @{} l @{}}
    A^{^J}\! = \psi\mapsto{} & \left(\!\fix\, \quadrants{\qbox1}{\lifted\psi}{\lifted\psi}{\lifted\psi}\right) \applt 
       ~\psi \mapsto \left(\!\fix\, \quadrants{\lifted\psi}{\qbox2}{\lifted\psi}{\lifted\psi}\right) \applt \\
       & \psi \mapsto \fix\, \quadrants{\lifted\psi}{\lifted\psi}{}{\qbox4} \\
    \lspan2{
     \quad
     \qbox1 \,\qbox2 \,\qbox4 \textit{ as in \Cref{tactics:A sliced}}
    }
  \end{array}
  \hspace{-8mm}
  \label{tactics:A stratified twice}
\end{equation}

\begin{center}
\begin{tacticboxInline}{Synth \qbox1}
    \renewcommand\arraystretch{1.3}
	\begin{array}{@{} l @{\quad} l @{}}
       h_1= \qbox1            &  h_{2,3,4}=\lifted\psi  \\
	   f_1 = A^{^{J_0}}\,\psi &  f_{2,3,4} = \psi       \\
	   \cspan2{\Y = J_0^2 \to \R}
   \end{array}
\end{tacticboxInline}
%
\begin{tacticboxInline}{Synth \qbox4}
    \renewcommand\arraystretch{1.3}
	\begin{array}{@{} l @{\quad} l @{}}
       h_{1,2} = \lifted\psi   &  h_3 = \qbox4         \\
	   f_{1,2} = \psi          &  f_3 = A^{^{J_1}}\,\psi  \\
	   \cspan2{\Y = J_1^2 \to \R}
   \end{array}
\end{tacticboxInline}
\end{center}

\begin{equation}
  \renewcommand\arraystretch{1.5}
  \begin{array}{@{} r @{} l @{}}
    A^{^J}\! = \psi\mapsto{} & \quadrants{A^{^{J_0}}\,\psi}{\psi}{\psi}{\psi} ~ \applt 
       ~\psi \mapsto \left(\!\fix\, \quadrants{\lifted\psi}{\qbox2}{\lifted\psi}{\lifted\psi}\right) \applt \\[5mm]
       & \psi \mapsto \quadrants{\psi}{\psi}{}{A^{^{J_1}}\,\psi} \\
    \lspan2{
     \quad
     \qbox2 \textit{ as in \Cref{tactics:A sliced}}
    }
  \end{array}
  \hspace{-5mm}
  \label{tactics:A synthed}
\end{equation}

For $\qbox2$\,, the situation is slightly more complicated because no instance of the routine
$A$ matches the specification and there are no other routines to choose from.
Richard defines a new routine $B^{J_0J_1}$ by carving the respective
subexpression from the developed program $A^J$.
Notice that $B$ has two parameters, because it depends not only on the index
range, but also on the particular partitioning.
Next, Richard will carry on developing $B$ in a similar manner.

\medskip
\hrule
\medskip

\subsection{Synthesis-powered {\sf Synth} Tactic}
\label{tactics:synthesis}

As mentioned in \Cref{intro,overview}, the user is assisted by automatic
inference while applying tactics. In particular, the {\sf Synth} tactic requires
the user to specify a subroutine to call and parameters to call it with.
In addition, the subtype $\Y$ is required to complete the correctness proof.
To automate this task, Bellmania employs Counterexample-guided Inductive Synthesis ({\cegis}), a software synthesis technique
implemented in the tool {\Sketch}~\cite{STTT13/Solar-Lezama}. The proof obligations, along with the possible
space of parameter assignments taken from the set of sub-types defined during
{\sf Slice}, are translated to {\Sketch}. Since {\Sketch} uses bounded domains,
the result is then verified using full SMT.

In addition to considering explicitly defined sub-types, the synthesizer also tries
small variations of them to cover corner cases. When index arithmetic is used,
the range for a sub-call may have to be extended by a row or column on one or more sides.
For each index sub-type $\T\subseteq J$, Bellmania also tries $\T\cup(\T\pm 1)$ for filling in values of parameters:
\[\T+1=\{i+1\;|\;i\in \T\} \qquad \T-1=\{i-1\;|\;i\in \T\}\]

While the number of combinations is not huge, 
it is usually hard for the user to figure out which exact call
should be made. Since {\sf Synth} is used extensively throughout the development,
This kind of automation greatly improves overall usability.

{\Sketch} times for the running example range 15--45 seconds.
For comparison, covering the same search space for a typical invocation via exhaustive search in C++ took about 1$\frac{1}{2}$ hours.

\begin{comment}
% This part I moved to the appendix

\subsection{Soundness}
\label{tactics:soundness}

\renewenvironment{proof}{\noindent{\bf Proof.~}}{}

\begin{theorem}
Let $s=s'$ be an instance of one of the tactics introduced in this section.
let $a_i=b_i$, $i=1..k$, be the proof obligations. If $\semp{a_i}=\semp{b_i}$
for all interpretations of the free variables of $a_i$ and $b_i$, then
$\semp{s}=\semp{s'}$ for all interpretations of the free variables of $s$ and $s'$.
\end{theorem}

\begin{proof}
For the tactics with \textbf{\textit{Obligations}:} tactic, the theorem is trivial.

\medskip
\noindent
{\tt >} For {\sf Stratify}, let $f$, $g$ be partial functions such that
\vspace{-.5em}
\[\renewcommand\arraystretch{1.3}
  \forall \theta,\zeta.\quad \begin{array}{l}f\,(g\,\zeta\,\theta) ~=~ f\,\zeta \quad\land\quad
  g\,(f\,\theta)\,\theta ~=~ h\,\theta
  \end{array}\quad\]
  
Assume that $\zeta = \fix f$ and $\theta = \fix (g\,\zeta)$. 
That is, $f\,\zeta = \zeta$ and $g\,\zeta\,\theta = \theta$.
Then ---
\vspace{-.5em}
\[\renewcommand\arraystretch{1.3}
  \begin{array}{l@{}l}
   h\,\theta & {}= g\,(f\,\theta)\,\theta = g\,(f\,(g\,\zeta\,\theta))\,\theta =
              g\,(f\,\zeta)\,\theta = \theta
  \end{array}\]
  
\noindent
So $\theta = \fix h$. We get $\fix h = \fix \big(g \,(\fix f)\big)$; equivalently,
\[\fix h = (\fix f) \applt \big(\psi\mapsto\fix (g\,\psi)\big)\]

Now instantiate $h$, $f$, and $g$, with $f\applt g$, $f$, and $g'$ from \Cref{tactics:Stratify obligations},
and we obtain the equality in the tactic.

\medskip
\noindent
{\tt >} For {\sf Synth}, ({\it i}) assume $f_i=\fix g$ and
\[h :: \T\to\Y = h :: \Y\to\Y = g :: \Y\to\T\]

Intuitively, $\Y$ ``cuts out'' a region of an array $\theta :: \T$ given
as input to $h$ and $g$. This area is self-contained, in the sense that
only elements in $\Y$ are needed to compute elements in $\Y$, as indicated
by the refined type $\Y\to\Y$.

Notice that from the premise follows $g :: \Y\to\T = g :: \Y\to\Y$. We use the following corollary:

\medskip\noindent
{\bf Corollary.~} Let $f : \T\to\T$; if either $f :: \T\to\Y = f :: \Y\to\Y$ or $f :: \Y\to\T = f :: \Y\to\Y$, 
then $(\fix f)::\Y = \fix (f :: \Y\to\Y)$.

Proof is included in the appendix.

\medskip
From the corollary, and for the given $h$ and $g$, we learn that $(\fix h)::\Y = \fix(h::\Y\to\Y)$,
and also $(\fix g)::\Y=\fix(g::\Y\to\Y)$. Since $h::\Y\to\Y=g::\Y\to\Y$,
we get $(\fix h)::\Y = (\fix g)::\Y$; now, $\Y$ is a supertype of $\T_i$, so $(\theta::\Y)::\T_i=\theta::\T_i$:
\[\renewcommand\arraystretch{1.3}
  \begin{array}{l}(\fix h)::\T_i = ((\fix h)::\Y)::\T_i = ((\fix g)::\Y)::\T_i = \\
    \qquad = (\fix g)::\T_i=f_i::\T_i
  \end{array}\]

{\it (ii)} Assume $h\,(h\,\theta) :: \T_i = f_i :: \T_i$ holds for any $\theta:\T$,
then in particlar, for $\theta=\fix\,h$, we get $h\,(h\,\fix h) :: \T_i = f_i :: \T_i$.
Since $h\,(h\,\fix h) = \fix h$, we obtain the conjecture $(\fix h) :: \T_i = f_i :: \T_i$.
\qed
\end{proof}

\medskip
Our reliance on the termination of $\fix$ expressions may seem conspicuous, since some of these
expressions are generated automatically by the system. However, a closer look reveals that whenever
such a computation is introduced, the set of the recursive calls it makes is a subset of those made by the existing one.
Therefore, if the original recurrence terminates, so does the new one. In any case, all the recurrences
in our development have a trivial termination argument (the indexes $i$,$j$ change monotonically between calls),
so practically, this should never become a problem.

\end{comment}