\section{Examples}

Many aspects of Bellmania are best illustrated via examples.
While the main sections include many such examples,
some more elaborated ones may prove useful and interesting.

\subsection{Development of Parenthesis (with diagrams)}
\label{annex:example:paren}

The running example from \Cref{intro,overview} has a total of three subroutines, which we label A, B, and C.
As promised, we include original design diagrams by the technique's authors taken from~\cite{PPoPP16/Chowdhury}.
The blocks (triangles) in the diagrams represent intermediate steps of the computation.
Below each diagram, we show a transcript of what the user has to type in when using Bellmania
to carry out the same development.

Boxed letters in the scripts are used to refer to sub-terms of the current program
(in \Cref{tactics} we used boxed digits, but in the actual UI we use letters
because there are more of them).
Reading the scripts in a non-interactive setting might be hard since the reader cannot
observe the program; they are listed here just to give an idea of the size and structure.
The supplementary material contains some screenshots of an interactive session.

\newcommand\xw[1]{w^x_{#1}}
\newcommand\yw[1]{w^y_{#1}}

\begin{figure}
\begin{center}
\includegraphics[width=.15\textwidth]{img/par-A.pdf}
\end{center}
%
\begin{lstlisting}[language=bellmania]
Slice (find (\theta |-> ?)) (? <|J_0*J_0, J_0*J_1, J_1*J_1|>)
Stratify "/" (fixee [A]) [A] \psi
Stratify "/" (fixee [A]) [A] \psi
[A] [B] [C] |-> SynthAuto . ... \psi
\end{lstlisting}
\caption{\label{annex:Paren-A}
Development of subroutine A of the Parenthesis problem as conceptually described in~\cite{PPoPP16/Chowdhury} (top) and using Bellmania (bottom).}
\end{figure}

\begin{figure}
\begin{center}
\includegraphics[width=.3\textwidth]{img/par-B.pdf}
\end{center}
%
\begin{lstlisting}[language=bellmania]
Slice f (? <|K_0*K_2, K_0*K_3, K_1*K_2, K_1*K_3|>)
[D] |-> Stratify "/" (fixee .) . \psi
[C] |-> Stratify "/" (fixee .) . \psi
[E] |-> Stratify "/" (fixee .) . \psi

<|Slice (find  (k |-> ?)) <|K_0, K_1, K_2, K_3|>,
 Slice (find  (k |-> ?)) <|K_1, K_2, K_3|>,
 Slice (find  (k |-> ?)) <|K_0, K_1, K_2|> |>

Distrib min
Assoc min

<|Stratify min (fixee $\lbox A$) <|$\lbox G$, $\lbox J$|> \psi,
 Stratify min (fixee $\lbox B$) <|$\lbox M$, $\lbox O$|> \psi,
 Stratify min (fixee $\lbox C$) <|$\lbox R$, $\lbox T$|> \psi |>
Stratify min (fixee $\lbox A$) $\langle \lbox{\,I\,}, \lbox K\rangle$ $\psi$

$\lbox{\,I\,}$ $\lbox S$ $\lbox Z$ $\underline{\lbox G}$ $\lbox M$ $\lbox P$ $\lbox W$ $\underline{\lbox D}$ |-> SynthAuto . ... \psi
\end{lstlisting}
\caption{\label{annex:Paren-B}
Same, for subroutine B of Parenthesis.}
\end{figure}

\begin{figure}
\begin{center}
\includegraphics[width=.3\textwidth]{img/par-B.pdf}
\end{center}
%
\begin{lstlisting}[language=bellmania]
Slice (find (i |-> ?)) <|L_0*L_4,L_0*L_5,L_1*L_4,L_1*L_5|>
Let "/" (slasher $\lbox A$) $\lbox A$ $\psi$
Let "/" (slasher $\lbox A$) $\lbox A$ $\psi$
Let "/" (slasher $\lbox A$) $\lbox A$ $\psi$
Slice (findAll ($k \mapsto {?}$)) $\langle L_2, L_3\rangle$

Distrib min
Assoc min

<|Let min (slasher $\lbox A$) $\langle\lbox E, \lbox G\rangle$ $\psi$,
 Let min (slasher $\lbox B$) $\langle\lbox H,\lbox {\,J\,}\rangle$ $\psi$,
 Let min (slasher $\lbox C$) $\langle\lbox K,\lbox M\rangle$ $\psi$,
 Let min (slasher $\lbox D$) $\langle\lbox N,\lbox P\rangle$ $\psi$ $\rangle$

$\lbox A$ $\lbox B$ $\lbox C$ $\lbox D$ $\lbox E$ $\lbox F$ $\lbox G$ $\lbox H$ |-> SynthAuto . ... $\psi$
\end{lstlisting}
\caption{Same, for subroutine C of Parenthesis}
\end{figure}

\vfill

\subsection{Qualified Type Inference}
\label{annex:example:type inference}

We provide an example of how qualifiers are inferred in program terms.

\medskip
\exampleTitle

\noindent Assume that:
\begin{itemize}
 \item $I$, $T$ are types
 \item $\widehat{I}_0 : I\to\B$ is a unary qualifier
 \item $0:T$ is a constant
 \item $\S$ a type variable, 
\end{itemize}
 
Consider the term $(f:I_0\to\S)\,i\mapsto f\,i\,i ~/~ 0$.
The first step of Hindley-Milner inference will induce the following type shapes through unification:

\begin{tikzpicture}[node distance=1em]
  \node(farg) {$(f:I\to\S)$};
  \node(iarg)[right=of farg] {$i$};
  \node(mapsto)[right=of iarg] {$\mapsto$};
  \node(f)[right=of mapsto] {$f$};
  \node(i1)[right=of f] {$i$};
  \node(i2)[right=of i1] {$i$};
  \node(slash)[right=of i2] {$\big/$};
  \node(zero)[right=of slash] {$0$};
  \node(l0)[coordinate,below=1mm of farg] {};
  \node(l1)[coordinate,below=4.5mm of l0] {};
  \node(l2)[coordinate,below=3.5mm of l1] {};
  \node(l3)[coordinate,below=3.5mm of l2] {};
  \node(l4)[coordinate,below=3.5mm of l3] {};
  \def\ytip{2pt}
  \draw (l0 -| farg.west) -- +(0,-\ytip) -| (l0 -| farg.east) node[pos=0.25,below] {\tiny $I\to I\to T$};
  \draw (l0 -| iarg.west) -- +(0,-\ytip) -| (l0 -| iarg.east) node[pos=0.25,below] {\tiny $I$};
  \draw (l0 -| f.west) -- +(0,-\ytip) -| (l0 -| f.east) node[pos=0.5,anchor=23,inner xsep=0] {\tiny $I\to I\to T$};
  \draw (l0 -| i1.west) -- +(0,-\ytip) -| (l0 -| i1.east) node[pos=0.25,below] {\tiny $I$};
  \draw (l0 -| i2.west) -- +(0,-\ytip) -| (l0 -| i2.east) node[pos=0.25,below] {\tiny $I$};
  \draw (l0 -| zero.west) -- +(0,-\ytip) -| (l0 -| zero.east) node[pos=0.25,below] {\tiny $T$};
  \draw (l1 -| f.west) -- +(0,-\ytip) -| (l1 -| i1.east) node[pos=0.25,below] {\tiny $I\to T$};
  \draw (l2 -| f.west) -- +(0,-\ytip) -| (l2 -| i2.east) node[pos=0.25,below] {\tiny $T$};
  \draw (l3 -| f.west) -- +(0,-\ytip) -| (l3 -| zero.east) node[pos=0.25,below] {\tiny $T$};
  \draw (l4 -| farg.west) -- +(0,-\ytip) -| (l4 -| zero.east) node[pos=0.25,below] {\tiny $(I\to I\to T)\to I\to T$};
  
  % numerals!
  \node[yshift=-1pt] at (farg.north east) {\tiny 0};
  \node at (iarg.north east) {\tiny 0};
  \node at (i1.north east) {\tiny 1};
  \node at (i2.north east) {\tiny 2};
  \node at (f.north east) {\tiny 1};
\end{tikzpicture}

Superscript numerals denote different occurrences of the same variable.
In this case, the type variable $\S$ has been assigned $I\to T$.

The process would have stopped here if it weren't for the qualifier $I_0$ used in the type for $f$.
At this point we can use type refinements to get more accurate types for $f$ and $i$
in the body of the function term.
%
\newcommand\oops[1]{^{\,^{\mbox{\tiny #1}}}}
\[
\frac{f:I_0\to I\to T, ~ i:I ~~\vdash~~ f\oops1 : I\to I\to T}
     {f:I_0\to I\to T, ~ i:I ~~\vdash~~ f\oops1 : I_0\to I\to T}
 \]
 
Notice that $(I\to I\to T)\sqcap (I_0\to I\to T) = I_0\to I \to T$. Truthfully, in this case this is quite a trivial result.

\smallskip
Let $\Gamma = \{f:I_0\to I\to T, ~ i:I\}$.
%
\[
\frac{\begin{array}{rcl} \Gamma & \vdash & (f\oops1\,i\oops1) : I\to T, 
                                        ~~ f\oops1: I_0\to I\to T,      
                                        ~~ i\oops1 : I                 \end{array}}
     {\begin{array}{rcl} \Gamma & \vdash & (f\oops1\,i\oops1) : I\to T, 
                                        ~~ f\oops1: I_0\to I\to T,      
                                        ~~ i\oops1 : I_0
     \end{array} }
     \]

The types of $f\oops1$ and $f\oops1\,i\oops1$ have not changed, but the type of $i\oops1$ was lowered to $I_0$.

\medskip
After applying the typing rules similarly to all the sub-terms, we get the inferred types as shown:

\begin{tikzpicture}[node distance=1em]
  \node(farg) {$(f:I_0\to\S)$};
  \node(iarg)[right=of farg] {$i$};
  \node(mapsto)[right=of iarg] {$\mapsto$};
  \node(f)[right=of mapsto] {$f$};
  \node(i1)[right=of f] {$i$};
  \node(i2)[right=of i1] {$i$};
  \node(slash)[right=of i2] {$\big/$};
  \node(zero)[right=of slash] {$0$};
  \node(l0)[coordinate,below=1mm of farg] {};
  \node(l1)[coordinate,below=4.5mm of l0] {};
  \node(l2)[coordinate,below=3.5mm of l1] {};
  \node(l3)[coordinate,below=3.5mm of l2] {};
  \node(l4)[coordinate,below=3.5mm of l3] {};
  \def\ytip{2pt}
  \draw (l0 -| farg.west) -- +(0,-\ytip) -| (l0 -| farg.east) node[pos=0.25,below] {\tiny $I_0\to I\to T$};
  \draw (l0 -| iarg.west) -- +(0,-\ytip) -| (l0 -| iarg.east) node[pos=0.25,below] {\tiny $I$};
  \draw (l0 -| f.west) -- +(0,-\ytip) -| (l0 -| f.east) node[pos=0.5,anchor=23,inner xsep=0] {\tiny $I_0\to I\to T$};
  \draw (l0 -| i1.west) -- +(0,-\ytip) -| (l0 -| i1.east) node[pos=0.25,below] {\tiny $I_0$};
  \draw (l0 -| i2.west) -- +(0,-\ytip) -| (l0 -| i2.east) node[pos=0.25,below] {\tiny $I$};
  \draw (l0 -| zero.west) -- +(0,-\ytip) -| (l0 -| zero.east) node[pos=0.25,below] {\tiny $T$};
  \draw (l1 -| f.west) -- +(0,-\ytip) -| (l1 -| i1.east) node[pos=0.25,below] {\tiny $I_0\to T$};
  \draw (l2 -| f.west) -- +(0,-\ytip) -| (l2 -| i2.east) node[pos=0.25,below] {\tiny $T$};
  \draw (l3 -| f.west) -- +(0,-\ytip) -| (l3 -| zero.east) node[pos=0.25,below] {\tiny $T$};
  \draw (l4 -| farg.west) -- +(0,-\ytip) -| (l4 -| zero.east) node[pos=0.25,below] {\tiny $(I_0\to I\to T)\to I\to T$};
\end{tikzpicture}

\medskip
\hrule
\vfill

\iftr % The Simplified Arbiter example overflows the page limit (20) and will appear in the TR
\pagebreak
\subsection{Simplified Arbiter}

To give another example of a development for a different problem, we provide a simplified version of the Gap problem (\Cref{evaluation}), which we call the Simplified Arbiter.
Two processes $x$ and $y$ must be scheduled to run $n$ and $m$ seconds,
respectively, on a single processor, using one-second slots.
Execution starts at $t=0$. The cost for scheduling the slots $[a..b)$ of $x$ after
having scheduled slots $[0..c)$ of $y$
is given by $\xw{abc}$, and the cost for schedulting the slots $[a..b)$ of $y$
after scheduling $[0..c)$ of $x$ is given by $\yw{abc}$.

In Bellmania language, the Simplified Arbiter example is specified by
a base case $\Psi$ and a computation
part $A^{IJ}$, where $I$ and $J$ are row and column index sets, respectively.

\[
  \renewcommand\arraystretch{1.5}
  \begin{array}{@{}l@{}l@{}c@{}c@{}l@{}l@{}}
    \Psi ~=~ & \lspan5{\fix \Big(\theta\,i\,j\mapsto
	              [0]_{i=j=0} ~\big/~ [\yw{0j0}]_{i=0} ~\big/~ [\xw{0i0}]_{j=0}\Big)} \\
    A^{^{IJ}} ~=~ 
	      & \psi\mapsto \fix \theta\,& i & j & \mapsto\min\,\langle~ & \psi_{ij} \\
	      & & ^{^{(I)}} & ^{^{(J)}} & & \min \vtyped p I \mapsto\theta_{pj}+w_{pij}, \\
	      & & & & & \min \vtyped q J \mapsto\theta_{iq}+w'_{qji} ~\rangle
  \end{array}
\]

Vertical typeset was used to save some horizontal space, but $\vtyped v\T$
should be read as just $v:\T$.

\medskip

After Richard applies {\sf Slice}, he gets the four quadrants $I_0\times J_0$, $I_0\times J_1$, $I_1\times J_0$, $I_1\times J_1$
(\Cref{overview:quadrants}). The system defined unary qualifiers with the axioms:
\[
\begin{array}{c@{\qquad}c}
  \forall i{:}I.~~I_0(i)\lor I_1(i)   &    \forall i_0{:}I_0,~i_1{:}I_1.~~i_0<i_1 \\
  \forall j{:}J.~~J_0(j)\lor J_1(j)   &    \forall j_0{:}J_0,~j_1{:}J_1.~~j_0<j_1 \\
\end{array}
\]

The program is just about to
grow quite large; to make such terms easy to read and refer to, we provide
boxed letters as labels for sub-terms, using them as abbreviations where they
occur in the larger expression

In addition, to allude to the reader's intuition, expressions of the form
$a/b/c/d$ will be written as $\quadrants*{a}{b}{c}{d}$ when the slices
represent quadrants.

\begin{tacticbox}{Slice}
  \begin{array}{@{} l  l @{}}
       f ~=~ \theta\,i\,j\mapsto \cdots \\
       X_1 ~=~ \_\times I_0\times J_0 &
       X_2 ~=~ \_\times I_0\times J_1 \\
       X_3 ~=~ \_\times I_1\times J_0 &
       X_4 ~=~ \_\times I_1\times J_1 \\[.5em]
       \cspan2{\mbox{\small ({\it each} ``\_'' {\it is a fresh type variable})}}
  \end{array}
\end{tacticbox}

\begin{equation}
  \renewcommand\arraystretch{1.2}
  \begin{array}{@{}r@{}l@{}c@{}c@{}l@{}l@{}}
    A^{^{IJ}} =~ & \lspan5{\psi\mapsto \fix \quadrants{\lbox A}{\lbox B}{\lbox C}{\lbox D}} \\
	\lbox A ~=~ & \theta\,& i & j & \mapsto\min\,\langle~ & \psi_{ij} \\
	      & & ^{^{(I_0)}} & ^{^{(J_0)}} & & \min \vtyped p I \mapsto\theta_{pj}+w_{pij}, \\
	      & & & & & \min \vtyped q J \mapsto\theta_{iq}+w'_{qji} ~\rangle \\
	\lbox B ~=~ & \theta\,& i & j & \mapsto\min\,\langle~ & \psi_{ij} \\
	      & & ^{^{(I_0)}} & ^{^{(J_1)}} & & \min \vtyped p I \mapsto\theta_{pj}+w_{pij}, \\
	      & & & & & \min \vtyped q J \mapsto\theta_{iq}+w'_{qji} ~\rangle \\
	\lbox C ~=~ & \theta\,& i & j & \mapsto\min\,\langle~ & \psi_{ij} \\
	      & & ^{^{(I_1)}} & ^{^{(J_0)}} & & \min \vtyped p I \mapsto\theta_{pj}+w_{pij}, \\
	      & & & & & \min \vtyped q J \mapsto\theta_{iq}+w'_{qji} ~\rangle \\
	\lbox D ~=~ & \theta\,& i & j & \mapsto\min\,\langle~ & \psi_{ij} \\
	      & & ^{^{(I_1)}} & ^{^{(J_1)}} & & \min \vtyped p I \mapsto\theta_{pj}+w_{pij}, \\
	      & & & & & \min \vtyped q J \mapsto\theta_{iq}+w'_{qji} ~\rangle \\
  \end{array}
  \label{evaluation:A sliced}
\end{equation}

\begin{tacticbox}{Let}
   e[\square] ~=~ \quadrants*{\square}{\lbox*B}{\lbox*C}{\lbox*D} \qquad
   t ~=~ \lbox A
\end{tacticbox}

\begin{equation}
  A^{^{IJ}} =~ \psi\mapsto \fix \left(\lbox A \applt z\mapsto\quadrants{z}{\lbox B}{\lbox C}{\lbox D}\right)
\end{equation}

\begin{tacticbox}{Stratify[with Padding]}
  \begin{array}{@{} l @{} l @{}}
    f ~=~ \quadrants*{\lbox*A}{\lifted\psi}{\lifted\psi}{\lifted\psi}
         & \mbox{\small ({\it recall that } $\lifted\psi=\theta\mapsto\psi$)} \\
    g ~=~ z\mapsto\quadrants*{z}{\lbox*{B}}{\lbox*C}{\lbox*D} &
    \qquad\psi=\psi
  \end{array}
\end{tacticbox}

\begin{equation}
  A^{^{IJ}} =~ \psi\mapsto \fix \quadrants{\lbox A}{\lifted\psi}{\lifted\psi}{\lifted\psi} ~\applt~ \psi\mapsto\fix\quadrants{\lifted\psi}{\lbox B}{\lbox C}{\lbox D}
  \label{evaluation:stratify A 1}
\end{equation}

Notice that an existing variable $\psi$ is reused, rebinding any occurrences within $\lbox B$, $\lbox C$, $\lbox D$.
This effect is useful, as it limits the context of the expression: the inner $\psi$ shadows the outer $\psi$,
meaning $\lbox B$, $\lbox C$, $\lbox D$ do not need to access the data that was input to $\lbox A$, only its
output.

\medskip
The sequence Let, Stratify[with Padding] is now applied in the same manner to $\lbox B$
and $\lbox C$ (see \Cref{overview:slice-stratify-synth}). We do not list the applications as they are analogous to the previous ones.

\begin{equation}
  \renewcommand\arraystretch{1.5}
  \begin{array}{l@{}l}
    A^{^{IJ}} =~ \psi\mapsto{} & \fix \quadrants{\lbox A}{\lifted\psi}{\lifted\psi}{\lifted\psi} ~\applt~ 
                 \psi\mapsto\fix\quadrants{\lifted\psi}{\lbox B}{\lifted\psi}{\lifted\psi} ~\applt \\
               & \psi\mapsto\fix\quadrants{\lifted\psi}{\lifted\psi}{\lbox C}{\lifted\psi} ~\applt~
                 \psi\mapsto\fix\quadrants{\lifted\psi}{\lifted\psi}{\lifted\psi}{\lbox D}
  \end{array}
\end{equation}

\begin{tacticbox}{Synth}
	\begin{array}{@{}l@{}c@{}c@{}l@{}l}
       \lspan5{h_1= \lbox A} \\
       \lspan5{h_{2,3,4}=\lifted\psi} \\
	   f_1 = \theta\,& i & j & \mapsto\min\,\langle~ & \psi_{ij} \\
	      & ^{^{(I_0)}} & ^{^{(J_0)}} & & \min \vtyped p {I_0} \mapsto\theta_{pj}+w_{pij}, \\
	      & & & & \min \vtyped q {J_0} \mapsto\theta_{iq}+w'_{qji} ~\rangle \\
	   \lspan5{f_{2,3,4} = \lifted\psi}
   \end{array}
\end{tacticbox}

\begin{equation}
  \renewcommand\arraystretch{1.5}
  \begin{array}{l@{}l}
    A^{^{IJ}} =~ \psi\mapsto{} & \quadrants{A^{^{I_0J_0}}_\psi\!\!\!}{\psi}{\psi}{\psi} ~\applt~ 
                 \psi\mapsto\fix\quadrants{\lifted\psi}{\lbox B}{\lifted\psi}{\lifted\psi} ~\applt \\
               & \psi\mapsto\fix\quadrants{\lifted\psi}{\lifted\psi}{\lbox C}{\lifted\psi} ~\applt~
                 \psi\mapsto\fix\quadrants{\lifted\psi}{\lifted\psi}{\lifted\psi}{\lbox D}
  \end{array}
  \label{fix A}
\end{equation}

We note that $\fix f_1=A^{^{I_0J_0}}_\psi$ are identical (up to $\beta$-reduction),
which is the whole reason $f_1$ was chosen. Also, we took the liberty
to simplify $\fix\lifted\psi$ into $\psi$ --- although this is not necessary --- just to display
a shorter term.

\medskip
The next few tactics will focus on the subterm $\lbox B$ from \eqref{evaluation:A sliced}.

\begin{equation}
  \renewcommand\arraystretch{1.2}
  \begin{array}{@{}r@{}l@{}c@{}c@{}l@{}l@{}}
	\lbox B ~=~ & \theta\,& i & j & \mapsto\min\,\langle~ & \psi_{ij} \\
	      & & ^{^{(I_0)}} & ^{^{(J_1)}} & & \min \vtyped p I \mapsto\theta_{pj}+w_{pij}, \\
	      & & & & & \min \vtyped q J \mapsto\theta_{iq}+w'_{qji} ~\rangle
  \end{array}
\end{equation}

\begin{tacticbox}{Slice}
  \begin{array}{@{} l @{}}
    f = \vtyped q J \mapsto \theta_{iq}+w'_{qji} \\
    X_1 = J_0\to\_ \qquad X_2 = J_1\to\_
  \end{array}
\end{tacticbox}

\begin{equation}
  \renewcommand\arraystretch{1.2}
  \begin{array}{@{}r@{}l@{}c@{}c@{}l@{}l@{}l@{}}
	\lbox B ~=~ & \theta\,& i & j & \mapsto\min\,\big\langle~ & \psi_{ij} \\
	      & & ^{^{(I_0)}} & ^{^{(J_1)}} & & \lspan2{\min \vtyped p I \mapsto\theta_{pj}+w_{pij},} \\
	      & & & & & \min \big( & (\vtyped q {J_0} \mapsto\theta_{iq}+w'_{qji}) ~\big/~ \\
	      & & & & & & (\vtyped q {J_1} \mapsto\theta_{iq}+w'_{qji})\big)  ~\big\rangle
  \end{array}
  \label{evaluation:horiz sliced}
\end{equation}

For the intuition behind this, see the top-right part of \Cref{evaluation:slicing strategy}.
The colors represent cell ranges that will be read by different sub-routines (presumably running on different cores).
The range of $q$ is split into the part that lies within \qbox1 ($q\in J_0$) and the one that
lies within \lbox2 ($q\in J_1$). The same reasoning is applied to the other quadrants.

\begin{tacticbox}{Distributivity}
  \begin{array}{@{} l @{}}
    e[\square] = \min\square \\
    t_1 = \min \vtyped q {J_0} \mapsto \theta_{iq}+w'_{qji} \\
    t_2 = \min \vtyped q {J_1} \mapsto \theta_{iq}+w'_{qji} \\
  \end{array}
\end{tacticbox}

\begin{tacticbox}{Associativity}
  \begin{array}{@{} l @{} l @{}}
    \lspan2{\reduce = \min} \\
    \overline x_1 ={} & \psi_{ij} \\
    \overline x_2 ={} & \min \vtyped p I \mapsto\theta_{pj}+w_{pij} \\
    \overline x_3 ={} & \min \vtyped q {J_0} \mapsto \theta_{iq}+w'_{qji} ~, \\
                      & \min \vtyped q {J_1} \mapsto \theta_{iq}+w'_{qji}
  \end{array}
\end{tacticbox}

\begin{equation}
  \renewcommand\arraystretch{1.2}
  \begin{array}{@{}r@{}l@{}c@{}c@{}l@{}l@{}}
	\lbox B ~=~ & \theta\,& i & j & \mapsto\min\,\big\langle~ & \psi_{ij} \\
	      & & ^{^{(I_0)}} & ^{^{(J_1)}} & & \min \vtyped p I \mapsto\theta_{pj}+w_{pij}, \\
	      & & & & & \min \vtyped q {J_0} \mapsto\theta_{iq}+w'_{qji}, \\
	      & & & & & \min \vtyped q {J_1} \mapsto\theta_{iq}+w'_{qji} ~\big\rangle
  \end{array}
\end{equation}

\begin{tacticbox}{Let[$\reduce$]}
  \begin{array}{@{} r @{} l @{}}
    e[\square] ={} & \quadrants{\lifted\psi}{\theta\,i\,j\mapsto\square}{\lifted\psi}{\lifted\psi} \\
    \overline a ={} & \psi_{ij}, ~\min \vtyped q{J_0}\mapsto \theta_{iq}+w'_{qji} \\
    \overline b ={} & \min \vtyped p I \mapsto\theta_{pj}+w_{pij}, \\
                    & \min \vtyped q {J_1} \mapsto\theta_{iq}+w'_{qji}
  \end{array}
\end{tacticbox}

\begin{equation}
  \renewcommand\arraystretch{1.2}
  \begin{array}{r @{} l @{} c @{} c @{} l @{} l}
    \lspan6{
    \quadrants{\lifted\psi}{\lbox B}{\lifted\psi}{\lifted\psi} =
      \fix\left(\lbox E \applt z\mapsto\quadrants{\lifted\psi}{\lbox F}{\lifted\psi}{\lifted\psi}\right) 
    } \\[1.5em]
    ~\lbox E ={} &
      \theta & i & j & \mapsto\min\langle & \psi_{ij}, \\
             & & ^{^{(I_0)}} & ^{^{(J_1)}} &
                                          & \min \vtyped q{J_0}\mapsto\theta_{iq}+w'_{qji} \rangle \\
    ~\lbox F ={} &
      \theta & i & j & \mapsto\min\langle & z_{\theta ij}, \\
             & & ^{^{(I_0)}} & ^{^{(J_1)}} &
                                         & \min \vtyped p I \mapsto\theta_{pj}+w_{pij}, \\
             & & & &                     & \min \vtyped q {J_1} \mapsto\theta_{iq}+w'_{qji}\rangle
  \end{array}
\end{equation}


\begin{figure}
\input{gfx/evaluation-slicing-strategy}
\medskip
\caption{\label{evaluation:slicing strategy}
  The strategy for applications of {\sf Slice} in the case study.}
\end{figure}

\begin{tacticbox}{Stratify[with Padding]}
  \begin{array}{@{} l @{}}
    f ~=~ \quadrants*{\lifted\psi}{\lbox*E}{\lifted\psi}{\lifted\psi} \\
    g ~=~ z\mapsto\quadrants*{\lifted\psi}{\lbox*F}{\lifted\psi}{\lifted\psi}
    \qquad\psi=\psi
  \end{array}
\end{tacticbox}

\begin{equation}
  \renewcommand\arraystretch{1.2}
  \begin{array}{r @{} l @{} c @{} c @{} l @{} l}
    \lspan6{
    \fix\quadrants{\lifted\psi}{\lbox B}{\lifted\psi}{\lifted\psi} =
      \fix\quadrants{\lifted\psi}{\lbox E}{\lifted\psi}{\lifted\psi} \applt
      \psi\mapsto\fix\quadrants{\lifted\psi}{\lbox F}{\lifted\psi}{\lifted\psi}
    } \\[1.5em]
    ~\lbox E ={} &
      \theta & i & j & \mapsto\min\langle & \psi_{ij}, \\
             & & ^{^{(I_0)}} & ^{^{(J_1)}} &
                                          & \min \vtyped q{J_0}\mapsto\theta_{iq}+w'_{qji} \rangle \\
    ~\lbox F ={} &
      \theta & i & j & \mapsto\min\langle & \psi_{ij}, \\
             & & ^{^{(I_0)}} & ^{^{(J_1)}} &
                                          & \min \vtyped p I \mapsto\theta_{pj}+w_{pij}, \\
             & & & &                      & \min \vtyped q {J_1} \mapsto\theta_{iq}+w'_{qji}\rangle
  \end{array}
\end{equation}

\noindent
Define
\begin{equation}
  \renewcommand\arraystretch{1.2}
  \begin{array}{@{}l @{} l @{\!} c @{} c @{} l @{} l@{}}
  B^{^{IJ_0J_1}} =~ \big( & \psi\mapsto \\
      & \fix
      \theta & i & j & \mapsto\min\langle & \psi_{ij}, \\
           & & ^{^{(I)}} & ^{^{(J)}} &
                                          & \min \vtyped q{J_0}\mapsto\theta_{iq}+w'_{qji} \rangle\big) \\
      & \lspan5{:: \big((I\times J_0)\to\R\big) \to \big((I\times J_1)\to\R\big)}
  \end{array}
\end{equation}

\begin{tacticbox}{Synth}
  \begin{array}{@{} l @{} c @{} c @{} l @{} l @{}}
    \lspan5{h_2 = \lbox E} \\
    \lspan5{h_{1,3,4} = \lifted\psi} \\
    f_2 = 
      \theta & i & j & \mapsto\min\langle & \psi_{ij}, \\
             & ^{^{(I_0)}} & ^{^{(J_1)}} &
                                          & \min \vtyped q {J_0} \mapsto\theta_{iq}+w'_{qji}\rangle \\
    \lspan5{f_{1,3,4} = \lifted\psi}
  \end{array}
\end{tacticbox}

\begin{tacticbox}{Synth}
  \begin{array}{@{} l @{} c @{} c @{} l @{} l @{}}
    \lspan5{h_2 = \lbox F} \\
    \lspan5{h_{1,3,4} = \lifted\psi} \\
    f_2 = 
      \theta & i & j & \mapsto\min\langle & \psi_{ij}, \\
             & ^{^{(I_0)}} & ^{^{(J_1)}} &
                                          & \min \vtyped p {I_0} \mapsto\theta_{pj}+w_{pij}, \\
             & & &                        & \min \vtyped q {J_1} \mapsto\theta_{iq}+w'_{qji}\rangle \\
    \lspan5{f_{1,3,4} = \lifted\psi}
  \end{array}
\end{tacticbox}

\begin{equation}
  \fix\quadrants{\lifted\psi}{\lbox B}{\lifted\psi}{\lifted\psi} ~=~
    \quadrants{\psi}{B^{^{I_0J_0J_1}}_\psi\!\!\!\!}{\psi}{\psi} ~\applt~
    \psi\mapsto\quadrants{\psi}{A^{^{I_0J_1}}_\psi\!\!\!}{\psi}{\psi}
  \label{fix B}
\end{equation}

\medskip\noindent
In a similar manner, we will obtain the following:

\begin{equation}
  \fix\quadrants{\lifted\psi}{\lifted\psi}{\lbox C}{\lifted\psi} ~=~
    \quadrants{\psi}{\psi}{C^{^{I_0I_1J_0}}_\psi\!\!\!\!}{\psi} ~\applt~
    \psi\mapsto\quadrants{\psi}{\psi}{A^{^{I_1J_0}}_\psi\!\!\!}{\psi}
  \label{fix C}
\end{equation}

\begin{equation}
  \renewcommand\arraystretch{1.2}
  \begin{array}{@{}l @{} l @{\!} c @{} c @{} l @{} l@{}}
  C^{^{I_0I_1J}} =~ \big( & \psi\mapsto \\
      & \fix
      \theta & i & j & \mapsto\min\langle & \psi_{ij}, \\
           & & ^{^{(I)}} & ^{^{(J)}} &
                                          & \min \vtyped p {I_0} \mapsto\theta_{pj}+w_{pij} \rangle\big) \\
      & \lspan5{:: \big((I_0\times J)\to\R\big) \to \big((I_1\times J)\to\R\big)}
  \end{array}
\end{equation}

\medskip\noindent
And ---

\begin{equation}
  \begin{array}{@{} l @{} l @{}}
    \fix\quadrants{\lifted\psi}{\lifted\psi}{\lifted\psi}{\lbox D} ~=~ &
      \quadrants{\psi}{\psi}{\psi}{B^{^{I_1J_0J_1}}_\psi\!\!\!\!} ~\applt~
      \psi\mapsto\quadrants{\psi}{\psi}{\psi}{C^{^{I_0I_1J_1}}_\psi\!\!\!} \\
    &
       ~\applt~ \psi\mapsto\quadrants{\psi}{\psi}{\psi}{A^{^{I_1J_1}}_\psi\!\!\!}
  \end{array}
  \label{fix D}
\end{equation}

This gives the stratified version as shown in \Cref{evaluation:arbiter stratify A chain}.
The read and write regions are already encoded in the types of $A$, $B$, $C$ in 
\eqref{fix A}, \eqref{fix B}, \eqref{fix C}, and \eqref{fix D}.

\begin{figure*}
\centering
\begin{tikzpicture}[>=latex,x=7mm,y=7mm,
    every path/.style={step=1},
    every node/.style={inner sep=.5pt},
    below edge/.style={below=1mm},
    above edge/.style={above=1mm},
    block/.style={rectangle,draw,thick,fill=blue, fill opacity=0.15, inner sep=0}]
    
  \def\dx{2.1cm}
  \def\dy{1cm}
  \def\w{3mm}
    
  \draw (0,0) grid (2,2);
  \node(1) at (.5,1.5) {1};   \node(2) at (1.5,1.5) {2};
  \node(3) at (.5,.5) {3};    \node(4) at (1.5,.5) {4};
  \node(s)[block,fit={(0,1) (1,2)}] {};

  \node[inner sep=0] at (2.5,1) {\includegraphics[width=\w]{img/arrow}};
  
  \tikzset{xshift=\dx}
  
  \draw (0,0) grid (2,2);
  \node(1) at (.5,1.5) {\,1$'$};   \node(2) at (1.5,1.5) {2};
  \node(3) at (.5,.5) {3};    \node(4) at (1.5,.5) {4};
  \draw[->] (s.60) to[out=30] node[above edge] {$A$} (1);
  \node(s)[block,fit={(.05,1) (2.05,2)}] {};
  \node(t)[block,fit={(0,2.05) (1,0)}] {};

  \node[inner sep=0] at (2.5,1) {\includegraphics[width=\w]{img/arrow}};
  
  \tikzset{xshift=\dx, yshift=\dy}
 
  \draw (0,0) grid (2,2);
  \node(1) at (.5,1.5) {\,1$'$};   \node(2) at (1.5,1.5) {\,2$'$};
  \node(3) at (.5,.5) {3};    \node(4) at (1.5,.5) {4};
  \draw[->] (s.60) to[out=80,looseness=1.2] node[above edge] {$B$} (2.120);
  \node(s)[block,fit={(1,1) (2,2)}] {};

  \tikzset{yshift=-2*\dy}
 
  \draw (0,0) grid (2,2);
  \node(1) at (.5,1.5) {\,1$'$};   \node(2) at (1.5,1.5) {2};
  \node(3) at (.5,.5) {\,3$'$};    \node(4) at (1.5,.5) {4};
  \draw[->] (t.-80) to[out=-60,in=-140] node[below edge] {$C$} (3.-120);
  \node(t)[block,fit={(0,0) (1,1)}] {};

  \tikzset{yshift=\dy} % back to middle

  \node[inner sep=0] at (2.5,1) {\includegraphics[width=\w]{img/arrow}};
  
  \tikzset{xshift=\dx}
  
  \draw (0,0) grid (2,2);
  \node(1) at (.5,1.5) {\,1$'$};   \node(2) at (1.5,1.5) {\,\,2$''$};
  \node(3) at (.5,.5) {\,\,3$''$};    \node(4) at (1.5,.5) {4};
  \draw[->] (s) to[out=40,in=120] node[above edge,xshift=1mm] {$A$}  (2);
  \draw[->] (t) to[out=-60,in=-120] node[below edge] {$A$}  (3);
  \node(s)[block,fit={(1,0) (2,2)}] {};

  \node[inner sep=0] at (2.5,1) {\includegraphics[width=\w]{img/arrow}};

  \tikzset{xshift=\dx}

  \draw (0,0) grid (2,2);
  \node(1) at (.5,1.5) {\,1$'$};   \node(2) at (1.5,1.5) {\,\,2$''$};
  \node(3) at (.5,.5) {\,\,3$''$};    \node(4) at (1.5,.5) {\,4$'$};
  \draw[->] (s.-80) to[out=-40,in=-120] node[below edge] {$C$}  (4);
  \node(s)[block,fit={(0,0) (2,1)}] {};

  \node[inner sep=0] at (2.5,1) {\includegraphics[width=\w]{img/arrow}};

  \tikzset{xshift=\dx}

  \draw (0,0) grid (2,2);
  \node(1) at (.5,1.5) {\,1$'$};   \node(2) at (1.5,1.5) {\,\,2$''$};
  \node(3) at (.5,.5) {\,\,3$''$};    \node(4) at (1.5,.5) {\,\,4$''$};
  \draw[->] (s.-40) to[out=-40,in=-120] node[below edge] {$B$} (4);
  \node(s)[block,fit={(1,0) (2,1)}] {};

  \node[inner sep=0] at (2.5,1) {\includegraphics[width=\w]{img/arrow}};

  \tikzset{xshift=\dx}

  \draw (0,0) grid (2,2);
  \node(1) at (.5,1.5) {\,1$'$};   \node(2) at (1.5,1.5) {\,\,2$''$};
  \node(3) at (.5,.5) {\,\,3$''$};    \node(4) at (1.5,.5) {\,\,\,4$'''$};
  \draw[->] (s.-80) to[out=-40,in=-120] node[below edge] {$A$} (4);

\end{tikzpicture}
\caption{\label{evaluation:arbiter stratify A chain}
  Fully divide-and-conquered version of $A^{IJ}$ in the example development.}
\end{figure*}


\medskip
\hrule
\bigskip

\fi% end of \iftr